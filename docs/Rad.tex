\documentclass[]{foi} % zakomentirati za pisanje rada na engleskom jeziku
% \documentclass[english]{foi} % odkomentirati za pisanje rada na engleskom jeziku
\usepackage[utf8]{inputenc}
\usepackage{lipsum}

\vrstaRada{\projekt}
% \zavrsni ili \diplomski ili \seminar ili \projekt

\title{Implementacija Web poslužitelja korištenjem funkcijskog pristupa}
\predmet{\predmetDP}
% ostaviti prazno ako \vrstaRada nije \projekt ili \seminar
% \predmetBP ili \predmetDP ili \predmetTBP ili \predmetVAS

\author{Hrvoje Lesar} % ime i prezime studenta/studentice
\spolStudenta{\musko} % \zensko ili \musko

\mentor{Bogdan Okreša Đurić} % ime i prezime mentora
\spolMentora{\musko} % \zensko ili \musko
\titulaProfesora{dr. sc.}
% HR: dr. sc.  / doc. dr. sc. / izv. prof. dr. sc. / prof. dr. sc. 
% EN: -prazno- / Asst. Prof.  / Assoc. Prof.       / Full Prof.

\godina{2023}
\mjesec{Siječanj} % mjesec obrane rada ili projekta

\indeks{0016133479} % broj indeksa ili JMBAG

\smjer{Organizacija poslovnih sustava}
% (ili:
%     Informacijski sustavi, 
%     Poslovni sustavi, 
%     Ekonomika poduzetništva, 
%     Primjena informacijske tehnologije u poslovanju, 
%     Informacijsko i programsko inženjerstvo, 
%     Baze podataka i baze znanja, 
%     Organizacija poslovnih sustava, 
%     Informatika u obrazovanju
% )


\sazetak{Opsega od 100 do 300 riječi. Sažetak upućuje na temu rada, ukratko se iznosi čime se rad bavi, teorijsko-metodološka polazišta, glavne teze i smjer rada te zaključci.}

\kljucneRijeci{riječ; riječ; ...riječ; Obuhvaća $7\pm2$ ključna pojma koji su glavni predmet rasprave u radu.}

\begin{document}

\maketitle

\tableofcontents

\makeatletter \def\@dotsep{4.5} \makeatother
\pagestyle{plain}

\chapter{Uvod}

\chapter{Funkcijsko programiranje}

Funkcijsko programiranje je pristup programiranju koji se temelji na pozivima funkcija kao primarnom konstruktu programiranja.
Općenito pruža praktične pristupe rješavanju problema i pruža uvide u mnoge aspekte računarstva \cite{michaelson2011introduction}.
Posebno, sa svojim korijenima u teoriji računarstva, čini poveznicu između formalnih metoda u računarstvu i njihovu primjenu.

Funkcijsko programiranje kao osnovu koristi $\lambda$-račun što znači da se problemi rješavaju korištenjem
isključivo korištenjem funkcija i njihovih povratnih vrijednosti. Glavna svojstva koja imaju funkcijski
programski jezici su nepromjenjivost stanja varijabli, čistoća funkciija, funkcije višeg reda. Više o glavnim svojstvima
u poglavlju \ref{sec:svojstva}. U funkcijskom programiranju programski kod se sastoji od definicije jedne
ili više funkcija, a izvođenje programa svodi se na izračunavanje funkcijskih izraza \cite{rovzic2016lambda}.

\section{Glavna svojstva funkcijsih programskih jezika} \label{sec:svojstva}

Funkcijsko programiranje nije ograničeno samo na funkcijske programske jezike,
mongi multiparadigmatski jezici omogućavaju funkcijski stil programiranja, no kod takvih je
potrebno poštivati slijedeća svojstva \cite{rovzic2016lambda}:
\begin{itemize}
	\item Nepromjenjivost stanja varijabli; Vrijednost varijable, objekta nije moguće promjeniti
	      nakon inicijalizacije. Ovakav pristup stvara veću sigurnost kod korištenja varijabli jer
	      smo sigurni da se varijabla kroz cijeli tok programa neće promijeniti. Kako bi se kreirale
	      nove varijable potrebno je izvršavanje funkcija koje vraćaju neku vrijednost.
	\item Čiste funkcije; Funkcije koje ne ovise o nikakvim vanjskim varijablama. Koriste jedino vrijednosti
	      koje su prosljeđene direktno u funkciju, te vrijednost prema svojstvu nepromijenjivosti ne može mijenjati.
	      Čiste funkcije garantiraju vraćanje iste vrijednosti prosljeđivanjem istih vrijednostu u funkciju,
	      ovo svojstvo pomaže kod optimizacije jer je funkciju potrebno pokrenuti i izračunati jedanput.
	      Čiste funkcije nemaju popratne posljedice osim kalkulacije razultata. Takav pristup eliminira
	      veliki izvor greška u programu i čini redoslijed izvršavanja nebitnim jer ne postoje popratne
	      posljedice te funkcija može biti evaluirana u bilo kojem trenutku \cite{hughes1989functional}.
	\item Funkcije prvog i višeg reda; Funkcije su tretirane kao objekti prvog reda tj. mogu biti rekurzivne,
	      višeg reda, polimorfne \cite{10.1145/72551.72554}. Funkcije višeg reda mogu primati kao argumente
	      druge funkcije te mogu vraćati funkcije kao povratne vrijednosti.
\end{itemize}

\chapter{Web poslužitelj}

Web poslužitelj u svojem najosnovnijem obliku isoporučuje klijentima zatražene dokumente preko weba.
Web se sastoji od tri glavne komponente \cite{yeager1996web}:
\begin{enumerate}
	\item Sistem adresa, URL-a (engl. Universal Resource Locators); Putanje koje omogućuju korisnicima
	      dohvaćanje gotovo bilo koju vrstu informacija s gotovo bilo kojeg mjesta na internetu
	\item HTTP (engl. HyperText Transfer Protocol); Najčešće korišteni protokol za komunikaciju između
	      klijenta i poslužitelja putem weba. Zbog svoje relativne jednostavnosti omogućuje mongim programima
	      zajednički rad.
	\item HTML (engl. HyperText Markup Language); Najčešće posluživana vrsta dokumenta na webu te je može
	      koristiti svaki web preglednik.
\end{enumerate}

Web poslužitelj s klijentima komunicira razmjenom poruka. Uspostavom veze između poslužitelja i klijenta,
klijent može poslati zahtjev poslužitelju. U slučaju HTTP-a klijent šalje zahtjev s određenom metodom,
ovisno o metodi šalje samo zaglavlje ili zaglavlje i tijelo poruke. HTTP zaglavlja su u tekstualnom obliku.
Poslužitelj, kod primanja zaglavlja, interpretira klijentov zahtjev i pokušava ispuniti zahtjev. Ovisno o
uspjehu ispunjenja zahtjeva poslužitelj šalje povratnu informaciju klijentu, povratna informacija se sastoji
od HTTP zaglavlja i ovisno o zahtijevu, neke HTML datoteke, teksta, slike, strukturiranih podataka.

\section{Primjer HTTP zahtjeva i odgovora}

Slijedeće predstavlja jednostavni HTTP zahtjev poslan s klijenta na poslužitelj:
\begin{verbatim}
GET /index.html HTTP/1.1
Accept: text/html,application/xml,image/webp,image/apng,*/*
User-Agent: Mozilla/5.0  Gecko/20100101 Firefox/108.0
\end{verbatim}

HTTP zahtjev počinje u prvoj liniji s metodom koju slijedi URL putanja te HTTP verzija, u ovom slučaju verzija 1.1.
Druga linija ukazuje kakve vrste dokumenata i podataka je klijent spreman primiti. U primjeru klijent eksplicitno ukazuje da
može primiti html, xml, webp ili bilo koju drugu vrstu datoteke na što ukazuje */* dio.
Zadnja linija identificira tip preglednika s kojega je poslan zahtjev.

Poslužitelj za zahtjev kreira odgovor. Odgovor uvijek u prvoj liniji sadrži status odgovora tj.
je li zahtjev uspio ili je odbijen. Slijedeće sadrži informacije o odgovoru, to su slično kao
kod zahtjeva, informacije o stvarnim zahtjevanim podacima, informacije o poslužitelju,
vrstu podattaka koji se šalju. Zadnji dio odgovora je dokument ili podatci koje je klijent
zatražio. Slijedeće je primjer odgovora na prije postavljeni zahtjev:
\begin{verbatim}
HTTP/1.1 200 OK
Content-Type: text/html
Content-Lenght: 40

<html>
<h1>Hello World!</h1>
</html>
\end{verbatim}
Prva linija odgovora je status odgovora, odgovor na zahtjev je uspješan što se može vidjeti iz
numeričke reprezentacije statusa 200 ili iz OK. Druga linija opisuje tip dokumenta koji je poslan
u odgovoru. U ovom slučaju je to html dokument, duljine 40 bajta. Prazna linija je odijeljak
zaglavlja odgovora i tijela odgovora. Ispod prazne linije nalazi se tijelo odgovora. Tijelo može
biti u tekstualnom ili binarnom obliku i u odgovorima sa tijelom se uvijek nalazi iza odijeljka.

\chapter{Implementacija web poslužitelja}

\section{Odabrani programski jezik i upute za pokretanje}
Web poslužitelj je implementiran u typescriptu, zbog lakšeg definiranje tipova podataka
i razumijevanja koda. Typescript je sintaktički nadskup javascript-a i potrebno ga je
konvertirati u javascript tj. transpilirati.

Za kompajliranje i pokretanje web poslužitelja potrebni su NodeJS, npm (node package manager) i typescript.
Ako su NodeJS i npm instalirani typescript se može globalno instalirati pokretanjem \texttt{npm install -g typescript}
u terminalu. Za pokretanje projekta potrebno se je postaviti u direktorij s datotekama \texttt{package.json} i
\texttt{tsconfig.json}. U tom direktoriju prvo pokrenuti \texttt{npm install} da npm pribavi potrebne pakete
za pokretanje programa (Program jedino zavisi o paketu \texttt{@types/node} koji sadrži NodeJS tipove za typescript).
Nakon pribavljanja paketa potrebno je transpilirati program što se odrađuje pokretanjem \texttt{tsc}, završetkom
transpilacije web poslužitelj se može pokrenuti s \texttt{node src/main.js}. Web poslužitelj se pokreće na
adresi \texttt{0.0.0.0:8888} ili \texttt{localhost:8888}.

\section{Implementacija}

Poslužitelj je implementiran poštivanjem funkcijskog pristupa, no neke funkcije nistu
potpuno "čiste" pošto moraju pisati na mrežu ili čitati sa diska. Slijedeća funkcija
pokreće web poslužitelj:
\begin{lstlisting}[caption={Funkcija za pokretanje web poslužitelja}, label=lst:pokretanje]
const createServer = (hostname: string, port: number, ...routes: Route[]) => {
    new net.Server()
        .listen(port, hostname, undefined, () => {
            console.log(`Server started on ${hostname}:${port}.`);
        })
        .on("connection", (socket: net.Socket) => {
            handleNewConnection(socket, routes);
        });
};
\end{lstlisting}
Funkcija kao ulaz prima hostname i port na kojemu se kreira server te varijabilni broj
ruta tj. putanja na kojima će pokušati odgovoriti na zahtjev klijenta. Metoda listen()
registrira server na unesenim hostname-u i portu, a metoda on() registrira događaj (event)
connection što poziva funkciju kad događaj okine.

Kod kreiranja poslužitelja potrebno je definirati na koje putanje će pokušati nešto izvršiti
te dati prikladan odgovor na zahtjev. Za sve putanje koje nisu definirane poslužitelj odgovara
sa 404 NOT FOUND. Ruta je definirana metodom koju očekuje (GET, POST), putanjom koju očekuje
i funkcijom koja će se izvršiti kod odgovaranja na zahtjev.
\begin{lstlisting}[caption={Definicija rute}, label=lst:ruta]
const route = (
    method: string,
    path: string,
    action: (socket: net.Socket, request: Request | undefined) => void
): Route => {
    return {
        method,
        path,
        action,
    };
};
\end{lstlisting}

Ovu funkciju poziva poslužitelj kod prihvaćanja nove veze i primanja zahtjeva od
klijenta. Funkcija nije čista jer koristi try, catch mehanizam, no u ovom slučaju
je potrebno jer inače kod greške na socketu bi se poslužitelj srušio. Funkcija nakon
primanja HTTP zahtjeva parsira zahtjev u strukturu pogodnu za program. Nakon toga pokuša
odrediti ako ruta odgovara nekoj od zadanih i ako pripada poziva funkciju koja generira
odgovarajući odgovor na zahtjev.
\begin{lstlisting}[caption={Prihvaćanje nove veze i zahtjeva}, label=lst:conn]
const handleNewConnection = (socket: net.Socket, routes: Route[]) => {
    socket.on("data", (buffer) => {
        try {
            const request = parseRequest(buffer.toString("utf8"));
            if (request) {
                const route = matchRoute(request, routes);
                if (route) {
                    const [nRequest, nRoute] = route;
                    nRoute.action(socket, nRequest);
                } else {
                    writeNotFoundToSocket(socket);
                }
            } else {
                writeNotFoundToSocket(socket);
            }
            socket.pipe(socket).end();
        } catch (e) {
            console.error(e);
        }
    });
};
\end{lstlisting}

\subsection{Rute} \
Web poslužitelj podržava tri vrste ruta.
\begin{enumerate}
	\item Puno definirane rute (/path/to/index.html);
	\item Wildcard rute (/path/to/*). Kod ove vrste ruta sve putanje nakon znaka \texttt{*}
	      su validne i poslužitelj će ih pokušati poslužiti
	\item Rute s varijabilnom putanjom (/path/\{to\}/\{resource\}). Ovakav tip ruta je koristan
	      pošto se vrijednosti u zagradama \texttt{varijabla} tretiraju kao varijable.
	      Primjer može biti pregled određenog zapisa u bazi podataka prema nekom identifikatoru
	      (GET /user/\{id\}).
\end{enumerate}
Web poslužitelj također ima mogućnost čitanja (samo na zadnjem dijelu putanje) niz upita (query
string). Niz upita nije posebno definiran kod kreiranja rute, već svaka ruta parsira
niz upita, ako postoji, te ga je moguće koristiti po potrebi.

Ova funkcija se prosljeđuje kao argument u \texttt{createServer} funkciju kako bi se
registrirala nova ruta na poslužitelju. Poslužitelj će na GET metodu koja ima putanju
\texttt{/} ili praznu putanju generirati odgovor čitanjem datoteke \texttt{index.html},
kreirati će odgovarajuće zaglavlje i u tijelo HTTP odgovora će dodati sadržaj pročitane
datoteke. Sljedeći isječak koda je primjer definiranje rute, sve rute su definirane u
poglavlju \ref{sec:rute}.
\begin{lstlisting}[caption={Primjer rute}, label=lst:primjer_rute]
route(HTTPMethods.GET, "/", (socket) => {
    compose(
        ([file, socket]: [string, net.Socket]) => {
            compose(
                ([response, socket]: [string, net.Socket]) => {
                    socket.write(response);
                },
                ([file, socket]: [string, net.Socket]) => {
                    return [
                        makeResponse(
                            STATUSCODES.OK,
                            [
                                ["Content-Lenght", file.length.toString()],
                                ["Content-Type", "text/html"],
                            ],
                            file
                        ),
                        socket,
                    ];
                }
            )([file, socket]);
        },
        (socket: net.Socket) => {
            return [
                readFileSync("./websites/index.html", {
                    encoding: "utf8",
                }),
                socket,
            ];
        }
    )(socket);
}),
\end{lstlisting}

\subsection{Definirane rute} \label{sec:rute}

Lista ruta na koje će trenutna implementacija web servera dati odgovore.
Rute su zapisane u obliku \texttt{METODA} \texttt{/PUTANJA} - objašnjenje.
\begin{itemize}
	\item \texttt{GET} \texttt{/} - Poslužuje index.html dokument koji ima primjere
	      za ostale putanje.
	\item \texttt{GET} \texttt{/websites/*} - Poslužuje sve putanje koje počinju sa /websites
	\item \texttt{GET} \texttt{/demo/\{variable\}/path/\{uri\}} - Primjer varijabilne putanje.
	      Vraća JSON objekt koji kao ključeve ima variable i uri, a vrijednosti će odgovarati
	      vrijednostima koje će biti napisane na mijestu variable i uri u putanje. Odlazak na
	      putanju /demo/changeme/path/value će vratiti ovakav JSON objekt: \{"variable": "changeme", "uri": "value"\}.
	\item \texttt{GET} \texttt{/query} - Putanja za prikaz rada niza upita. Na kraj putanje može
	      se dodati upit tipa \texttt{?field=value\&anotherField=anotherValue}, te će poslužitelj
	      vratiti JSON objekt s unesenim upitom tj. upitima ako ih je više.
\end{itemize}

\section{Prikaz rada}

\chapter{Zaključak}

Ovdje treba sažeto rezimirati najvažnije rezultate razrade teme rada. Potrebno je sažeto opisati što je predmet rada \cite{copeland2020ArtificialIntelligence}, koje su metode, tehnike, programski alati ili aplikacije korištene u razradi rada te koje su pretpostavke dokazane, a koje opovrgnute. Sadržajno, ono što se u uvodu rada najavljuje i kasnije je obuhvaćeno u samom radu, moralo bi biti opisano u zaključnom dijelu kroz rezultate rada.

\lipsum[1-2]

\makebackmatter
% generira popis korištene literature, popis slika (ako je primjenjivo), popis tablica (ako je primjenjivo) i popis isječaka koda (ako je primjenjivo)

\appendices % ako nije potrebno, obrisati ili zakomentirati
\end{document}
